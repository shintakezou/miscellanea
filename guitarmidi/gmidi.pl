#! /usr/bin/perl

## gmidi.pl 1.0
## generate a midi from a text, thought for guitar tablature
##
## Copyright (C) 2006 Mauro Panigada
##
##     This program is free software; you can redistribute it and/or modify
##     it under the terms of the GNU General Public License as published by
##     the Free Software Foundation; either version 2 of the License, or
##     (at your option) any later version.
##
##     This program is distributed in the hope that it will be useful,
##     but WITHOUT ANY WARRANTY; without even the implied warranty of
##     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##     GNU General Public License for more details.
##
##     You should have received a copy of the GNU General Public License
##     along with this program; if not, write to the Free Software
##     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


## FIXME sustain does not work


# buffer
my $buf = '';
my $fh;


# default midi instr.
my $instr = 25;

# default resolution is 192 [726]
my $resol = 726;
my $squash = 4;     # TODO this should be calculated, according to resol and tempo;
my $mc_per_qn = 24;   # MIDI ticks per quarter note ???
my $mc_per_dotted_qn = 3*$mc_per_qn/2;
my $n32_per_qn = 8;

# default duration time is a quarter note
my $dur = 4;

# for other kind of duration (terzine, dotted and so on)
my $durdiv = 1;

# default time is 4/4
my $timen = 4;
my $timed = 2; # power of 2

# default tempo is 120
my $tempo = 120;

# default volume and expression
my $volume = 110;
my $expr = 100;

# inc dec for cresc and dim (TODO)
my $inc_dec=0;
my $inc_dec_act = $expr;

# sustain status
my $sustain = 0;
my @sustainnotes = ();

# panning
my $pan = 64;

# default velocity s
my $velocity_d = 96;             # normal down stroke velocity
my $velocity_d_a = 110;          # accented down stroke vel
my $velocity_u = 94;             # normal up stroke vel
my $velocity_u_a = 109;          # accentend up stroke vel
my $velocity_s   = 127;          # sforzando velocity
my $velocity = $velocity_d;

# events bytes emitted (numbers of);
my $eventi = 0;

# this become 1 after the first note event is emitted; since then, it is not
# possible to put some kind of events (future version implementation's sake)
my $notevent = 0;

# more over, if no time, tempo and other MUST-BE-AT-LEAST-ONE-IN-THE-HEADER stuffs
# are set, this is still void, and then before emitting the first note we have
# to emit basic MIDI setup without we cannot play a single note.
# When basic setup is done before a note event has been emitted, a key/value
# pair is added, so we can check what is done and what is not and add some needed
# stuffs.
my %basesetup = ();

# chord symbols map
my %chname;

# current chord description (default current chord is C major, C bass)
my @playing = ( "x", 3, 2, 0, 1, 0 );

# guitar symbolic tuning, default to standard guitar tuning
my @stuning = ( "E4", "A4", "D5", "G5", "B5", "E6" );

# guitar tuning, after mapping from symbols to MIDI keys
my @tuning;


# appendend rest
my $arest = 0;
my $arestdiv = 1;




# midikeys; autogenerated pairs symbols->midikey, e.g. C5 => 60
my %midikeys;

sub gen_midikeys
{
    my @noteorder = ("C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B");
    my $ind;
    my $oct;
    my $cs;

    my $octave;
    for my $i (60..127) {
	$ind = ($i - 60) % 12;
	$oct = int(($i - 60)/12);
	$octave = 5+$oct;
	$cs = join("",$noteorder[$ind],$octave);
	$midikeys{$cs} = $i;
	# print STDERR "*** $cs tuned as mini key $i\n";
	if ( $cs =~ /^.#/ ) {
	    $ind = ( $ind + 1 ) % 12;
	    $cs = join("",$noteorder[$ind],"b",$octave);
	    $midikeys{$cs} = $i;
	    # print STDERR "*** $cs tuned as mini key $i\n";
	}
    }
    for (my $i = 60; $i >= 0; $i--) {
	$ind = $i % 12;
	$oct = int(($i)/12);
	$cs = join("",$noteorder[$ind],$oct);
	$midikeys{$cs} = $i;
	# print STDERR "*** $cs tuned as mini key $i\n";
	if ( $cs =~ /^.#/ ) {
	    $ind = ( $ind + 1 ) % 12;
	    $cs = join("",$noteorder[$ind],"b",$oct);
	    $midikeys{$cs} = $i;
	    # print STDERR "*** $cs tuned as mini key $i\n";
	}
    }
}


# maps from symbolic tuning to midi keys
sub tuning_map
{
    # first clear the array
    @tuning = ();
    foreach my $el (@stuning)
    {
	push @tuning, $midikeys{$el};
    }
}


# emit time and tempo if not emitted at the beginning
sub emit_base
{
    if ( !defined( $basesetup{'tempo'} ) )
    {
	emit_tempo();
	$basesetup{'tempo'} = 1;
    }
    if ( !defined( $basesetup{'time'} ) )
    {
	emit_time();
	$basesetup{'time'} = 1;
    }
    if ( !defined( $basesetup{'programchange'} ) )
    {
	emit_pc();
	$basesetup{'programchange'} = 1;
    }
    if ( !defined( $basesetup{'volume'} ) )
    {
	emit_volume();
	$basesetup{'volume'} = 1;
    }
    if ( !defined( $basesetup{'expression'} ) )
    {
	emit_expr();
	$basesetup{'expression'} = 1;
    }
    if ( !defined( $basesetup{'pan'} ) )
    {
	emit_pan();
	$basesetup{'pan'} = 1;
    }
}


# emit program change
sub emit_pc
{
    print { $fh } pack("a[2]","\x00\xC0");
    print { $fh } pack("C",$instr);
    $eventi += 3;
}

# emit pan
sub emit_pan
{
    print { $fh } pack("a[3]","\x00\xB0\x0A");
    print { $fh } pack("C",$pan);
    $eventi += 4;
}


# emit volume
sub emit_volume
{
    print { $fh } pack("a[3]C","\x00\xB0\x07",$volume);
    $eventi += 4;
}

# emit expression
sub emit_expr
{
    print { $fh } pack("a[3]C","\x00\xB0\x0B",$expr);
    $eventi += 4;
}


# emit delta
sub emit_delta
{
    # delta time are nothing but time distance from the previous event
    # expressed as a 7bit sequence where each 8th (higher) bit of the
    # byte says if there another byte following or not:
    # e.g. 00         zero time delta
    #      7F         127 time delta; the maximum value you can express with
    #                 a single byte
    #      81 00      this is 128:
    #                 1000 0001 0000 0000
    #                  \______/  \______/ -> 000 0001 000 0000
    my $tt = shift(@_);
    my $app=$tt;
    my @trunk;


    while($app>0)
    {
	$tt = $app % 128;
	$app = int($app / 128);
	push @trunk, $tt;
    }
    for (my $i=$#trunk; $i>=0; $i--)
    {
	if ( $i > 0 ) {
	    print { $fh } pack("C",$trunk[$i]+0x80);
	    $eventi++;
	} else {
	    print { $fh } pack("C",$trunk[$i]);
	    $eventi++;
	}
    }
}


# stop suspended notes on command
sub emit_stop_suspended
{
    return if ( scalar(@sustainnotes) == 0 );

    my $calcd = 4*$resol*$durdiv/$dur;
    my $status = 0;
    my $fl = 0;
    for my $el (@sustainnotes)
    {
	if ( $fl eq 0 )
	{
	    if ( $arest eq 0 )
	    {
		emit_delta($calcd);
	    } else {
		my $apprest = 4*$resol*$arestdiv/$arest;
		emit_delta($apprest+$calcd);
		$arest = 0;
		$arestdiv = 1;
	    }
	    $fl = 1;
	} else {
	    print { $fh } pack("C",0);
	    $eventi += 1;
	}
	if ( $status eq 0 ) {
	    print { $fh } pack("a[1]CC","\x80",$el,127);
	    $eventi += 3;
	    $status = 1;
	} else {
	    print { $fh } pack("CC",$el,127);
	    $eventi += 2;
	}
    }
    @sustainnotes = ();
}


# shared code for emit_*_stroke
sub emit_stroke
{
    my $argom = shift(@_);
    my $from;
    my $squishval = $squash;


    # here have to emit expr change if cresc or dim actived

    if ( $argom < 0 )
    {
	$from = 5;
    } else {
	$from = 0;
    }

    my $calcd = 4*$resol*$durdiv/$dur;
    # 4*resol = tic di base per 4/4
    my $squish = 0;
    my $apprest;

    my @noton;
    my $status = 0; # use running status

    emit_stop_suspended();

    $status = 0;
    my $i = $from;
    while ( $argom < 0 ? ($i >= 0) : ($i <= 5))
    {
	if ( $playing[$i] =~ /x/ ) 
	{
	    $i += $argom;
	    next;
	}
	    
	my $nota = $tuning[$i] + $playing[$i];

	push @noton, $nota;

	if ( $status eq 0 ) {
	    if ( $arest ne 0 )
	    {
		$apprest = 4*$resol*$arestdiv/$arest;
		emit_delta($apprest);
		print { $fh } pack("a[1]CC","\x90",$nota,$velocity);
		$eventi += 3;
		$arest = 0;
		$arestdiv = 1;
	    } else {
		print { $fh } pack("ca[1]CC",$squish,"\x90",$nota,$velocity);
		$eventi += 4;
	    }
	    $status = 1;
	} else {
	    print { $fh } pack("CCC",$squish,$nota,$velocity);
	    $eventi += 3;
	}
	if ( $squish eq 0 )
	{
	    $squish = $squishval;
	}
	$i += $argom;
    }


    my $fl = 0;
    $status = 0;

    if ( $sustain eq 0 )
    {
	for my $el (@noton)
	{
	    if ( $fl eq 0 )
	    {
		emit_delta($calcd - $squish*scalar(@noton));
		$fl = 1;
	    } else {
		print { $fh } pack("C",0);
		$eventi += 1;
	    }
	    if ( $status eq 0 ) {
		print { $fh } pack("a[1]CC","\x80",$el,127);
		$eventi += 3;
		$status = 1;
	    } else {
		print { $fh } pack("CC",$el,127);
		$eventi += 2;
	    }
	}
    } else {
	# turn off notes later... on a user command (or next chord)
	@sustainnotes = @noton;
    }
}

# up stroke
sub emit_up_stroke
{
    emit_base();

    emit_stroke(-1);
}


# down stroke
sub emit_down_stroke
{
    emit_base();

    emit_stroke(+1);
}


# emit tempo event
sub emit_tempo
{
    print { $fh } pack("a[4]", "\x00\xFF\x51\x03");
    # print { $fh } pack("a[3]","\x07\xA1\x20");        # fixed for test
    my $spb = int(60*1000000/$tempo);
    # 60s in a minute, 1000000 microseconds in a second
    # $tempo=120 means therefore 500000
    # Last Modified: 20070303
    print { $fh } pack("CCC",$spb>>16, $spb>>8, $spb);
    $eventi += 7;
}


# emit time
sub emit_time
{
    print { $fh } pack("a[4]", "\x00\xFF\x58\x04");
    print { $fh } pack("C",$timen);
    print { $fh } pack("C",$timed);
    print { $fh } pack("C",$mc_per_dotted_qn);
    print { $fh } pack("C",$n32_per_qn);
    $eventi += 8;
}


# put a rest (silence)
sub emit_rest
{
    emit_base();
    $arest = $dur;
    $arestdiv = $durdiv;
}


# ------------------------------------------------------------------------- MAIN
gen_midikeys();
tuning_map();

open $fh, ">", \$buf or die;


# READ STANDARD IN FOR COMMANDS ------------------------------------------- MAIN
my $linecnt = 0;
while(<STDIN>)
{
    chomp;
    $linecnt++;
    #print STDERR "parsing line: $linecnt\n";
    next if /^#/;
    next if /^\s*$/;
    my @cmd = split(/\s+/);


    for my $comando (@cmd) {

	if ( $comando =~ /^[x\d]{6}/ ) {
	    print STDERR "chord change $comando\n";
	    for my $i (0..5) {
		$playing[$i] = substr($comando, $i, 1);
	    }

	} elsif ( $comando =~ /^q(\d+)(\.?)(\.?)/ ) {
	    print STDERR "set hit length $1\n";
	    $dur = $1;
	    if ( "$1" == "." && "$2" == "" )
	    {
		$dur = $dur*2;
		$durdiv = 3;
	    } elsif ( "$2" == "." ) {
		$dur = $dur*4;
		$durdiv = 5;
	    } else {
		$durdiv = 1;
	    }

	} elsif ( $comando =~ /^v(v?)(v?)/ ) {
	    #print STDERR "low note to high fast hit\n";
	    $velocity = ("$1"=="v")?$velocity_d_a:$velocity_d;
	    $velocity = ("$2"=="v")?$velocity_s:$velocity;
	    emit_down_stroke();
	} elsif ( $comando =~ /^\^(\^?)(\^?)/ ) {
	    #print STDERR "high note to low fast hit\n";
	    $velocity = ("$1"=="^")?$velocity_u_a:$velocity_u;
	    $velocity = ("$2"=="^")?$velocity_s:$velocity;
	    emit_up_stroke();
	    # CHANGED 20070327, now accepts /_ too, but
	    # first must be upper/lower case letter or number.
	} elsif ( $comando =~ /^=([A-Za-z0-9][A-Za-z0-9#\/_]*)/ ) {
	    print STDERR "memo chord as $1\n";
	    if ( !defined($chname{$1}) ) {
		$chname{$1} = join("",@playing);
	    } else {
		print STDERR "Chord $1 was already defined\n";
	    }

	} elsif ( $comando =~ /^\+([A-Za-z0-9][A-Za-z0-9#\/_]*)/ ) {
	    print STDERR "use memo-ed chord called $1\n";
	    if ( defined( $chname{$1} ) ) {
		for my $i (0..5) {
		    $playing[$i] = substr($chname{$1}, $i, 1);
		}
	    } else {
		print STDERR "Chord $1 never defined\n";
	    }

	} elsif ( $comando =~ /^t=(\d+)/ ) {
	    print STDERR "set tempo to $1\n";
	    $tempo = $1;
	    emit_tempo();

	} elsif ( $comando =~ /^ts=(\d+),(\d+)/ ) {
	    print STDERR "set time signature to $1/$2";
	    $timen = $1;
	    $timed = $2;
	    emit_time();

	} elsif ( $comando =~ /^tune=([A-Z][b#]?\d+)([A-Z][b#]?\d+)([A-Z][b#]?\d+)([A-Z][b#]?\d+)([A-Z][b#]?\d+)([A-Z][b#]?\d+)/ ) {
	    print STDERR "tuning changed to $1 $2 $3 $4 $5 $6\n";
	    $stuning[0] = $1;
	    $stuning[1] = $2;
	    $stuning[2] = $3;
	    $stuning[3] = $4;
	    $stuning[4] = $5;
	    $stuning[5] = $6;
	    tuning_map();

	} elsif ( $comando =~ /^p/ ) {
	    #print STDERR "insert rest";
	    emit_rest();
	} elsif ( $comando =~ /^vol=(\d+)/ ) {
	    $volume = $1 % 128;
	    emit_volume();
	} elsif ( $comando =~ /^e=(\d+)/ ) {
	    $expr = $1 % 128;
	    emit_expr();
	} elsif ( $comando =~ /^i=(\d+)/ ) {
	    $instr = $1 % 128;
	    emit_pc();
	} elsif ( $comando =~ /^pan=([-+]?\d+)/ ) {
	    $pan = ($1 + 64) % 128;
	    emit_pan();
	} elsif ( $comando =~ /^s$/ ) {
	    emit_stop_suspended();
	}
    }
}


# midi header
print pack("a[12]", "MThd\x00\x00\x00\x06\x00\x00\x00\x01");
print pack("n", $resol);

# track chunk
print pack("a[4]", "MTrk");

# length of the track (bytes)
print pack("N", $eventi);

# events
print pack("a[$eventi]", $buf);

# track end
print pack("a[4]", "\x00\xFF\x2F\x00");

close($fh);

print STDERR "MIDI written to stdout\n";

#EOF
